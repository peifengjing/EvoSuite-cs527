/*
 * This file was automatically generated by EvoSuite
 * Thu Oct 12 20:16:28 GMT 2017
 */

package org.joda.time.field;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.MockitoExtension.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.util.Collection;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.joda.time.Chronology;
import org.joda.time.DateTimeField;
import org.joda.time.DateTimeFieldType;
import org.joda.time.DurationField;
import org.joda.time.ReadablePartial;
import org.joda.time.field.SkipUndoDateTimeField;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true) 
public class SkipUndoDateTimeField_ESTest extends SkipUndoDateTimeField_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      Chronology chronology0 = mock(Chronology.class, new ViolatedAssumptionAnswer());
      Chronology chronology1 = mock(Chronology.class, new ViolatedAssumptionAnswer());
      Chronology chronology2 = mock(Chronology.class, new ViolatedAssumptionAnswer());
      DateTimeField dateTimeField0 = mock(DateTimeField.class, new ViolatedAssumptionAnswer());
      doReturn(0L).when(dateTimeField0).add(anyLong() , anyInt());
      doReturn(0, 0).when(dateTimeField0).get(anyLong());
      doReturn((DurationField) null).when(dateTimeField0).getDurationField();
      doReturn(0).when(dateTimeField0).getMaximumTextLength(any(java.util.Locale.class));
      doReturn(0).when(dateTimeField0).getMinimumValue();
      doReturn((DateTimeFieldType) null).when(dateTimeField0).getType();
      doReturn((int[]) null).when(dateTimeField0).set(any(org.joda.time.ReadablePartial.class) , anyInt() , any(int[].class) , anyString() , any(java.util.Locale.class));
      SkipUndoDateTimeField skipUndoDateTimeField0 = new SkipUndoDateTimeField(chronology2, dateTimeField0, 30);
      assertEquals(1, skipUndoDateTimeField0.getMinimumValue());
      assertNotNull(skipUndoDateTimeField0);
      
      DurationField durationField0 = skipUndoDateTimeField0.getDurationField();
      assertEquals(1, skipUndoDateTimeField0.getMinimumValue());
      assertNull(durationField0);
      
      SkipUndoDateTimeField skipUndoDateTimeField1 = new SkipUndoDateTimeField(chronology1, skipUndoDateTimeField0);
      assertFalse(skipUndoDateTimeField1.equals((Object)skipUndoDateTimeField0));
      assertEquals(1, skipUndoDateTimeField0.getMinimumValue());
      assertEquals(0, skipUndoDateTimeField1.getMinimumValue());
      assertNotNull(skipUndoDateTimeField1);
      
      SkipUndoDateTimeField skipUndoDateTimeField2 = new SkipUndoDateTimeField(chronology0, skipUndoDateTimeField1);
      assertFalse(skipUndoDateTimeField0.equals((Object)skipUndoDateTimeField1));
      assertFalse(skipUndoDateTimeField1.equals((Object)skipUndoDateTimeField0));
      assertFalse(skipUndoDateTimeField2.equals((Object)skipUndoDateTimeField1));
      assertFalse(skipUndoDateTimeField2.equals((Object)skipUndoDateTimeField0));
      assertEquals(1, skipUndoDateTimeField0.getMinimumValue());
      assertEquals(0, skipUndoDateTimeField1.getMinimumValue());
      assertEquals(0, skipUndoDateTimeField2.getMinimumValue());
      assertNotNull(skipUndoDateTimeField2);
      
      long long0 = skipUndoDateTimeField2.add(1L, 30);
      assertEquals(0L, long0);
      assertFalse(skipUndoDateTimeField0.equals((Object)skipUndoDateTimeField2));
      assertFalse(skipUndoDateTimeField0.equals((Object)skipUndoDateTimeField1));
      assertFalse(skipUndoDateTimeField1.equals((Object)skipUndoDateTimeField2));
      assertFalse(skipUndoDateTimeField1.equals((Object)skipUndoDateTimeField0));
      assertFalse(skipUndoDateTimeField2.equals((Object)skipUndoDateTimeField1));
      assertFalse(skipUndoDateTimeField2.equals((Object)skipUndoDateTimeField0));
      assertEquals(1, skipUndoDateTimeField0.getMinimumValue());
      assertEquals(0, skipUndoDateTimeField1.getMinimumValue());
      assertEquals(0, skipUndoDateTimeField2.getMinimumValue());
      assertNotSame(skipUndoDateTimeField0, skipUndoDateTimeField2);
      assertNotSame(skipUndoDateTimeField0, skipUndoDateTimeField1);
      assertNotSame(skipUndoDateTimeField1, skipUndoDateTimeField2);
      assertNotSame(skipUndoDateTimeField1, skipUndoDateTimeField0);
      assertNotSame(skipUndoDateTimeField2, skipUndoDateTimeField1);
      assertNotSame(skipUndoDateTimeField2, skipUndoDateTimeField0);
      
      int int0 = skipUndoDateTimeField1.getMaximumTextLength((Locale) null);
      assertEquals(0, int0);
      assertFalse(skipUndoDateTimeField0.equals((Object)skipUndoDateTimeField2));
      assertFalse(skipUndoDateTimeField0.equals((Object)skipUndoDateTimeField1));
      assertFalse(skipUndoDateTimeField1.equals((Object)skipUndoDateTimeField2));
      assertFalse(skipUndoDateTimeField1.equals((Object)skipUndoDateTimeField0));
      assertEquals(1, skipUndoDateTimeField0.getMinimumValue());
      assertEquals(0, skipUndoDateTimeField1.getMinimumValue());
      assertNotSame(skipUndoDateTimeField0, skipUndoDateTimeField2);
      assertNotSame(skipUndoDateTimeField0, skipUndoDateTimeField1);
      assertNotSame(skipUndoDateTimeField1, skipUndoDateTimeField2);
      assertNotSame(skipUndoDateTimeField1, skipUndoDateTimeField0);
      
      int int1 = skipUndoDateTimeField1.get((-4068L));
      assertEquals(1, int1);
      assertFalse(skipUndoDateTimeField0.equals((Object)skipUndoDateTimeField2));
      assertFalse(skipUndoDateTimeField0.equals((Object)skipUndoDateTimeField1));
      assertFalse(skipUndoDateTimeField1.equals((Object)skipUndoDateTimeField2));
      assertFalse(skipUndoDateTimeField1.equals((Object)skipUndoDateTimeField0));
      assertFalse(int1 == int0);
      assertEquals(1, skipUndoDateTimeField0.getMinimumValue());
      assertEquals(0, skipUndoDateTimeField1.getMinimumValue());
      assertNotSame(skipUndoDateTimeField0, skipUndoDateTimeField2);
      assertNotSame(skipUndoDateTimeField0, skipUndoDateTimeField1);
      assertNotSame(skipUndoDateTimeField1, skipUndoDateTimeField2);
      assertNotSame(skipUndoDateTimeField1, skipUndoDateTimeField0);
      
      int int2 = skipUndoDateTimeField2.getMinimumValue();
      assertEquals(0, int2);
      assertFalse(skipUndoDateTimeField0.equals((Object)skipUndoDateTimeField2));
      assertFalse(skipUndoDateTimeField0.equals((Object)skipUndoDateTimeField1));
      assertFalse(skipUndoDateTimeField1.equals((Object)skipUndoDateTimeField2));
      assertFalse(skipUndoDateTimeField1.equals((Object)skipUndoDateTimeField0));
      assertFalse(skipUndoDateTimeField2.equals((Object)skipUndoDateTimeField1));
      assertFalse(skipUndoDateTimeField2.equals((Object)skipUndoDateTimeField0));
      assertFalse(int2 == int1);
      assertTrue(int2 == int0);
      assertEquals(1, skipUndoDateTimeField0.getMinimumValue());
      assertEquals(0, skipUndoDateTimeField1.getMinimumValue());
      assertEquals(0, skipUndoDateTimeField2.getMinimumValue());
      assertNotSame(skipUndoDateTimeField0, skipUndoDateTimeField2);
      assertNotSame(skipUndoDateTimeField0, skipUndoDateTimeField1);
      assertNotSame(skipUndoDateTimeField1, skipUndoDateTimeField2);
      assertNotSame(skipUndoDateTimeField1, skipUndoDateTimeField0);
      assertNotSame(skipUndoDateTimeField2, skipUndoDateTimeField1);
      assertNotSame(skipUndoDateTimeField2, skipUndoDateTimeField0);
      
      ReadablePartial readablePartial0 = mock(ReadablePartial.class, new ViolatedAssumptionAnswer());
      int[] intArray0 = new int[4];
      intArray0[0] = 30;
      intArray0[1] = 0;
      intArray0[2] = 0;
      intArray0[3] = 0;
      Locale locale0 = Locale.FRANCE;
      assertEquals("fra", locale0.getISO3Language());
      assertEquals("fr_FR", locale0.toString());
      assertEquals("FRA", locale0.getISO3Country());
      assertEquals("FR", locale0.getCountry());
      assertEquals("", locale0.getVariant());
      assertEquals("fr", locale0.getLanguage());
      assertNotNull(locale0);
      
      int[] intArray1 = skipUndoDateTimeField2.set(readablePartial0, 1, intArray0, "^q@mzZ0'sjHdw%,NO", locale0);
      assertArrayEquals(new int[] {30, 0, 0, 0}, intArray0);
      assertFalse(skipUndoDateTimeField0.equals((Object)skipUndoDateTimeField2));
      assertFalse(skipUndoDateTimeField0.equals((Object)skipUndoDateTimeField1));
      assertFalse(skipUndoDateTimeField1.equals((Object)skipUndoDateTimeField2));
      assertFalse(skipUndoDateTimeField1.equals((Object)skipUndoDateTimeField0));
      assertFalse(skipUndoDateTimeField2.equals((Object)skipUndoDateTimeField1));
      assertFalse(skipUndoDateTimeField2.equals((Object)skipUndoDateTimeField0));
      assertEquals("fra", locale0.getISO3Language());
      assertEquals("fr_FR", locale0.toString());
      assertEquals("FRA", locale0.getISO3Country());
      assertEquals("FR", locale0.getCountry());
      assertEquals("", locale0.getVariant());
      assertEquals("fr", locale0.getLanguage());
      assertEquals(1, skipUndoDateTimeField0.getMinimumValue());
      assertEquals(0, skipUndoDateTimeField1.getMinimumValue());
      assertEquals(0, skipUndoDateTimeField2.getMinimumValue());
      assertNotSame(skipUndoDateTimeField0, skipUndoDateTimeField2);
      assertNotSame(skipUndoDateTimeField0, skipUndoDateTimeField1);
      assertNotSame(skipUndoDateTimeField1, skipUndoDateTimeField2);
      assertNotSame(skipUndoDateTimeField1, skipUndoDateTimeField0);
      assertNotSame(skipUndoDateTimeField2, skipUndoDateTimeField1);
      assertNotSame(skipUndoDateTimeField2, skipUndoDateTimeField0);
      assertNull(intArray1);
      
      int int3 = skipUndoDateTimeField1.get(30);
      assertEquals(1, int3);
      assertTrue(int3 == int1);
      assertFalse(int3 == int0);
      assertFalse(int3 == int2);
      assertFalse(skipUndoDateTimeField0.equals((Object)skipUndoDateTimeField2));
      assertFalse(skipUndoDateTimeField0.equals((Object)skipUndoDateTimeField1));
      assertFalse(skipUndoDateTimeField1.equals((Object)skipUndoDateTimeField2));
      assertFalse(skipUndoDateTimeField1.equals((Object)skipUndoDateTimeField0));
      assertEquals(1, skipUndoDateTimeField0.getMinimumValue());
      assertEquals(0, skipUndoDateTimeField1.getMinimumValue());
      assertNotSame(skipUndoDateTimeField0, skipUndoDateTimeField2);
      assertNotSame(skipUndoDateTimeField0, skipUndoDateTimeField1);
      assertNotSame(skipUndoDateTimeField1, skipUndoDateTimeField2);
      assertNotSame(skipUndoDateTimeField1, skipUndoDateTimeField0);
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      Chronology chronology0 = mock(Chronology.class, new ViolatedAssumptionAnswer());
      DateTimeFieldType dateTimeFieldType0 = mock(DateTimeFieldType.class, new ViolatedAssumptionAnswer());
      DateTimeField dateTimeField0 = mock(DateTimeField.class, new ViolatedAssumptionAnswer());
      doReturn((int[]) null).when(dateTimeField0).addWrapPartial(any(org.joda.time.ReadablePartial.class) , anyInt() , any(int[].class) , anyInt());
      doReturn(598).when(dateTimeField0).get(anyLong());
      doReturn("-").when(dateTimeField0).getAsShortText(anyLong());
      doReturn(1731).when(dateTimeField0).getMaximumTextLength(any(java.util.Locale.class));
      doReturn(598, 423).when(dateTimeField0).getMaximumValue();
      doReturn((-3245)).when(dateTimeField0).getMinimumValue();
      doReturn(dateTimeFieldType0).when(dateTimeField0).getType();
      doReturn((long)1731).when(dateTimeField0).remainder(anyLong());
      doReturn((long)(-2562)).when(dateTimeField0).set(anyLong() , anyInt());
      SkipUndoDateTimeField skipUndoDateTimeField0 = new SkipUndoDateTimeField(chronology0, dateTimeField0);
      assertEquals((-3244), skipUndoDateTimeField0.getMinimumValue());
      assertNull(skipUndoDateTimeField0.getName());
      assertNotNull(skipUndoDateTimeField0);
      
      int int0 = skipUndoDateTimeField0.getMaximumValue();
      assertEquals(598, int0);
      assertEquals((-3244), skipUndoDateTimeField0.getMinimumValue());
      assertNull(skipUndoDateTimeField0.getName());
      
      SkipUndoDateTimeField skipUndoDateTimeField1 = new SkipUndoDateTimeField(chronology0, skipUndoDateTimeField0, 93);
      assertFalse(skipUndoDateTimeField1.equals((Object)skipUndoDateTimeField0));
      assertEquals((-3244), skipUndoDateTimeField0.getMinimumValue());
      assertNull(skipUndoDateTimeField0.getName());
      assertEquals((-3243), skipUndoDateTimeField1.getMinimumValue());
      assertNull(skipUndoDateTimeField1.getName());
      assertNotNull(skipUndoDateTimeField1);
      
      Locale locale0 = Locale.FRANCE;
      assertEquals("fra", locale0.getISO3Language());
      assertEquals("fr_FR", locale0.toString());
      assertEquals("FRA", locale0.getISO3Country());
      assertEquals("fr", locale0.getLanguage());
      assertEquals("", locale0.getVariant());
      assertEquals("FR", locale0.getCountry());
      assertNotNull(locale0);
      
      int int1 = skipUndoDateTimeField1.getMaximumTextLength(locale0);
      assertEquals(1731, int1);
      assertFalse(skipUndoDateTimeField0.equals((Object)skipUndoDateTimeField1));
      assertFalse(skipUndoDateTimeField1.equals((Object)skipUndoDateTimeField0));
      assertFalse(int1 == int0);
      assertEquals((-3244), skipUndoDateTimeField0.getMinimumValue());
      assertNull(skipUndoDateTimeField0.getName());
      assertEquals((-3243), skipUndoDateTimeField1.getMinimumValue());
      assertNull(skipUndoDateTimeField1.getName());
      assertEquals("fra", locale0.getISO3Language());
      assertEquals("fr_FR", locale0.toString());
      assertEquals("FRA", locale0.getISO3Country());
      assertEquals("fr", locale0.getLanguage());
      assertEquals("", locale0.getVariant());
      assertEquals("FR", locale0.getCountry());
      assertNotSame(skipUndoDateTimeField0, skipUndoDateTimeField1);
      assertNotSame(skipUndoDateTimeField1, skipUndoDateTimeField0);
      
      int[] intArray0 = new int[3];
      intArray0[0] = 292272992;
      intArray0[1] = 93;
      intArray0[2] = 93;
      int[] intArray1 = skipUndoDateTimeField1.addWrapPartial((ReadablePartial) null, (-247), intArray0, 31);
      assertArrayEquals(new int[] {292272992, 93, 93}, intArray0);
      assertFalse(skipUndoDateTimeField0.equals((Object)skipUndoDateTimeField1));
      assertFalse(skipUndoDateTimeField1.equals((Object)skipUndoDateTimeField0));
      assertEquals((-3244), skipUndoDateTimeField0.getMinimumValue());
      assertNull(skipUndoDateTimeField0.getName());
      assertEquals((-3243), skipUndoDateTimeField1.getMinimumValue());
      assertNull(skipUndoDateTimeField1.getName());
      assertNotSame(skipUndoDateTimeField0, skipUndoDateTimeField1);
      assertNotSame(skipUndoDateTimeField1, skipUndoDateTimeField0);
      assertNull(intArray1);
      
      int int2 = skipUndoDateTimeField1.get(93);
      assertEquals(598, int2);
      assertFalse(skipUndoDateTimeField0.equals((Object)skipUndoDateTimeField1));
      assertFalse(skipUndoDateTimeField1.equals((Object)skipUndoDateTimeField0));
      assertTrue(int2 == int0);
      assertFalse(int2 == int1);
      assertEquals((-3244), skipUndoDateTimeField0.getMinimumValue());
      assertNull(skipUndoDateTimeField0.getName());
      assertEquals((-3243), skipUndoDateTimeField1.getMinimumValue());
      assertNull(skipUndoDateTimeField1.getName());
      assertNotSame(skipUndoDateTimeField0, skipUndoDateTimeField1);
      assertNotSame(skipUndoDateTimeField1, skipUndoDateTimeField0);
      
      long long0 = skipUndoDateTimeField0.remainder(598);
      assertEquals(1731L, long0);
      assertFalse(skipUndoDateTimeField0.equals((Object)skipUndoDateTimeField1));
      assertEquals((-3244), skipUndoDateTimeField0.getMinimumValue());
      assertNull(skipUndoDateTimeField0.getName());
      assertNotSame(skipUndoDateTimeField0, skipUndoDateTimeField1);
      
      String string0 = skipUndoDateTimeField0.getAsShortText((long) 93);
      assertEquals("-", string0);
      assertFalse(skipUndoDateTimeField0.equals((Object)skipUndoDateTimeField1));
      assertEquals((-3244), skipUndoDateTimeField0.getMinimumValue());
      assertNull(skipUndoDateTimeField0.getName());
      assertNotSame(skipUndoDateTimeField0, skipUndoDateTimeField1);
      assertNotNull(string0);
      
      long long1 = skipUndoDateTimeField0.set(1538L, 0);
      assertEquals((-2562L), long1);
      assertFalse(long1 == long0);
      assertFalse(skipUndoDateTimeField0.equals((Object)skipUndoDateTimeField1));
      assertEquals((-3244), skipUndoDateTimeField0.getMinimumValue());
      assertNull(skipUndoDateTimeField0.getName());
      assertNotSame(skipUndoDateTimeField0, skipUndoDateTimeField1);
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      Chronology chronology0 = mock(Chronology.class, new ViolatedAssumptionAnswer());
      Chronology chronology1 = mock(Chronology.class, new ViolatedAssumptionAnswer());
      DateTimeFieldType dateTimeFieldType0 = mock(DateTimeFieldType.class, new ViolatedAssumptionAnswer());
      doReturn((String) null, (String) null).when(dateTimeFieldType0).getName();
      DateTimeField dateTimeField0 = mock(DateTimeField.class, new ViolatedAssumptionAnswer());
      doReturn((-2428)).when(dateTimeField0).get(anyLong());
      doReturn((-292269337)).when(dateTimeField0).getMaximumValue();
      doReturn((-2428)).when(dateTimeField0).getMinimumValue();
      doReturn(dateTimeFieldType0).when(dateTimeField0).getType();
      SkipUndoDateTimeField skipUndoDateTimeField0 = new SkipUndoDateTimeField(chronology1, dateTimeField0, 0);
      assertNull(skipUndoDateTimeField0.getName());
      assertEquals((-2427), skipUndoDateTimeField0.getMinimumValue());
      assertNotNull(skipUndoDateTimeField0);
      
      SkipUndoDateTimeField skipUndoDateTimeField1 = new SkipUndoDateTimeField(chronology0, skipUndoDateTimeField0);
      assertFalse(skipUndoDateTimeField1.equals((Object)skipUndoDateTimeField0));
      assertNull(skipUndoDateTimeField0.getName());
      assertEquals((-2427), skipUndoDateTimeField0.getMinimumValue());
      assertNull(skipUndoDateTimeField1.getName());
      assertEquals((-2426), skipUndoDateTimeField1.getMinimumValue());
      assertNotNull(skipUndoDateTimeField1);
      
      int int0 = skipUndoDateTimeField1.get(0L);
      assertEquals((-2426), int0);
      assertFalse(skipUndoDateTimeField0.equals((Object)skipUndoDateTimeField1));
      assertFalse(skipUndoDateTimeField1.equals((Object)skipUndoDateTimeField0));
      assertNull(skipUndoDateTimeField0.getName());
      assertEquals((-2427), skipUndoDateTimeField0.getMinimumValue());
      assertNull(skipUndoDateTimeField1.getName());
      assertEquals((-2426), skipUndoDateTimeField1.getMinimumValue());
      assertNotSame(skipUndoDateTimeField0, skipUndoDateTimeField1);
      assertNotSame(skipUndoDateTimeField1, skipUndoDateTimeField0);
      
      // Undeclared exception!
      try { 
        skipUndoDateTimeField0.set((long) (-2428), (-1586));
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Value -1586 for null must be in the range [-2427,-292269337]
         //
         verifyException("org.joda.time.field.FieldUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      Chronology chronology0 = mock(Chronology.class, new ViolatedAssumptionAnswer());
      DateTimeFieldType dateTimeFieldType0 = mock(DateTimeFieldType.class, new ViolatedAssumptionAnswer());
      doReturn((String) null, (String) null).when(dateTimeFieldType0).getName();
      DateTimeField dateTimeField0 = mock(DateTimeField.class, new ViolatedAssumptionAnswer());
      doReturn(1318, 0).when(dateTimeField0).getMaximumValue();
      doReturn((-2063)).when(dateTimeField0).getMinimumValue();
      doReturn(dateTimeFieldType0).when(dateTimeField0).getType();
      SkipUndoDateTimeField skipUndoDateTimeField0 = new SkipUndoDateTimeField(chronology0, dateTimeField0, 3824);
      assertEquals((-2062), skipUndoDateTimeField0.getMinimumValue());
      assertNull(skipUndoDateTimeField0.getName());
      assertNotNull(skipUndoDateTimeField0);
      
      SkipUndoDateTimeField skipUndoDateTimeField1 = new SkipUndoDateTimeField(chronology0, skipUndoDateTimeField0);
      assertFalse(skipUndoDateTimeField1.equals((Object)skipUndoDateTimeField0));
      assertEquals((-2062), skipUndoDateTimeField0.getMinimumValue());
      assertNull(skipUndoDateTimeField0.getName());
      assertEquals((-2061), skipUndoDateTimeField1.getMinimumValue());
      assertNull(skipUndoDateTimeField1.getName());
      assertNotNull(skipUndoDateTimeField1);
      
      // Undeclared exception!
      try { 
        skipUndoDateTimeField1.set((long) 3824, 355);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Value 355 for null must be in the range [-2062,0]
         //
         verifyException("org.joda.time.field.FieldUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      Chronology chronology0 = mock(Chronology.class, new ViolatedAssumptionAnswer());
      Chronology chronology1 = mock(Chronology.class, new ViolatedAssumptionAnswer());
      Chronology chronology2 = mock(Chronology.class, new ViolatedAssumptionAnswer());
      DateTimeField dateTimeField0 = mock(DateTimeField.class, new ViolatedAssumptionAnswer());
      doReturn(0).when(dateTimeField0).get(anyLong());
      doReturn(0).when(dateTimeField0).getMinimumValue();
      doReturn((DateTimeFieldType) null).when(dateTimeField0).getType();
      SkipUndoDateTimeField skipUndoDateTimeField0 = new SkipUndoDateTimeField(chronology2, dateTimeField0, 1137);
      assertEquals(1, skipUndoDateTimeField0.getMinimumValue());
      assertNotNull(skipUndoDateTimeField0);
      
      SkipUndoDateTimeField skipUndoDateTimeField1 = new SkipUndoDateTimeField(chronology2, skipUndoDateTimeField0);
      assertFalse(skipUndoDateTimeField1.equals((Object)skipUndoDateTimeField0));
      assertEquals(1, skipUndoDateTimeField0.getMinimumValue());
      assertEquals(0, skipUndoDateTimeField1.getMinimumValue());
      assertNotNull(skipUndoDateTimeField1);
      
      DateTimeFieldType dateTimeFieldType0 = skipUndoDateTimeField1.getType();
      assertFalse(skipUndoDateTimeField0.equals((Object)skipUndoDateTimeField1));
      assertFalse(skipUndoDateTimeField1.equals((Object)skipUndoDateTimeField0));
      assertEquals(1, skipUndoDateTimeField0.getMinimumValue());
      assertEquals(0, skipUndoDateTimeField1.getMinimumValue());
      assertNotSame(skipUndoDateTimeField0, skipUndoDateTimeField1);
      assertNotSame(skipUndoDateTimeField1, skipUndoDateTimeField0);
      assertNull(dateTimeFieldType0);
      
      DateTimeField dateTimeField1 = mock(DateTimeField.class, new ViolatedAssumptionAnswer());
      doReturn(31449600000L).when(dateTimeField1).addWrapField(anyLong() , anyInt());
      doReturn(2277, 1640).when(dateTimeField1).getMaximumValue();
      doReturn((-292269054)).when(dateTimeField1).getMinimumValue();
      doReturn((DateTimeFieldType) null).when(dateTimeField1).getType();
      doReturn((long)2277).when(dateTimeField1).roundHalfFloor(anyLong());
      doReturn((long)2277).when(dateTimeField1).set(anyLong() , anyInt());
      SkipUndoDateTimeField skipUndoDateTimeField2 = new SkipUndoDateTimeField(chronology1, dateTimeField1, (-1447));
      assertFalse(skipUndoDateTimeField2.equals((Object)skipUndoDateTimeField1));
      assertFalse(skipUndoDateTimeField2.equals((Object)skipUndoDateTimeField0));
      assertEquals((-292269053), skipUndoDateTimeField2.getMinimumValue());
      assertNotNull(skipUndoDateTimeField2);
      
      long long0 = skipUndoDateTimeField2.roundHalfFloor((-999L));
      assertEquals(2277L, long0);
      assertFalse(skipUndoDateTimeField2.equals((Object)skipUndoDateTimeField1));
      assertFalse(skipUndoDateTimeField2.equals((Object)skipUndoDateTimeField0));
      assertEquals((-292269053), skipUndoDateTimeField2.getMinimumValue());
      assertNotSame(skipUndoDateTimeField2, skipUndoDateTimeField1);
      assertNotSame(skipUndoDateTimeField2, skipUndoDateTimeField0);
      
      SkipUndoDateTimeField skipUndoDateTimeField3 = new SkipUndoDateTimeField(chronology0, skipUndoDateTimeField2);
      assertFalse(skipUndoDateTimeField2.equals((Object)skipUndoDateTimeField1));
      assertFalse(skipUndoDateTimeField2.equals((Object)skipUndoDateTimeField0));
      assertFalse(skipUndoDateTimeField3.equals((Object)skipUndoDateTimeField2));
      assertFalse(skipUndoDateTimeField3.equals((Object)skipUndoDateTimeField1));
      assertFalse(skipUndoDateTimeField3.equals((Object)skipUndoDateTimeField0));
      assertEquals((-292269053), skipUndoDateTimeField2.getMinimumValue());
      assertEquals((-292269052), skipUndoDateTimeField3.getMinimumValue());
      assertNotNull(skipUndoDateTimeField3);
      
      int int0 = skipUndoDateTimeField2.getMaximumValue();
      assertEquals(2277, int0);
      assertFalse(skipUndoDateTimeField2.equals((Object)skipUndoDateTimeField1));
      assertFalse(skipUndoDateTimeField2.equals((Object)skipUndoDateTimeField3));
      assertFalse(skipUndoDateTimeField2.equals((Object)skipUndoDateTimeField0));
      assertEquals((-292269053), skipUndoDateTimeField2.getMinimumValue());
      assertNotSame(skipUndoDateTimeField2, skipUndoDateTimeField1);
      assertNotSame(skipUndoDateTimeField2, skipUndoDateTimeField3);
      assertNotSame(skipUndoDateTimeField2, skipUndoDateTimeField0);
      
      long long1 = skipUndoDateTimeField3.addWrapField((-973L), 1428);
      assertEquals(31449600000L, long1);
      assertFalse(skipUndoDateTimeField2.equals((Object)skipUndoDateTimeField1));
      assertFalse(skipUndoDateTimeField2.equals((Object)skipUndoDateTimeField3));
      assertFalse(skipUndoDateTimeField2.equals((Object)skipUndoDateTimeField0));
      assertFalse(skipUndoDateTimeField3.equals((Object)skipUndoDateTimeField2));
      assertFalse(skipUndoDateTimeField3.equals((Object)skipUndoDateTimeField1));
      assertFalse(skipUndoDateTimeField3.equals((Object)skipUndoDateTimeField0));
      assertFalse(long1 == long0);
      assertEquals((-292269053), skipUndoDateTimeField2.getMinimumValue());
      assertEquals((-292269052), skipUndoDateTimeField3.getMinimumValue());
      assertNotSame(skipUndoDateTimeField2, skipUndoDateTimeField1);
      assertNotSame(skipUndoDateTimeField2, skipUndoDateTimeField3);
      assertNotSame(skipUndoDateTimeField2, skipUndoDateTimeField0);
      assertNotSame(skipUndoDateTimeField3, skipUndoDateTimeField2);
      assertNotSame(skipUndoDateTimeField3, skipUndoDateTimeField1);
      assertNotSame(skipUndoDateTimeField3, skipUndoDateTimeField0);
      
      int int1 = skipUndoDateTimeField3.getMinimumValue();
      assertEquals((-292269052), int1);
      assertFalse(skipUndoDateTimeField2.equals((Object)skipUndoDateTimeField1));
      assertFalse(skipUndoDateTimeField2.equals((Object)skipUndoDateTimeField3));
      assertFalse(skipUndoDateTimeField2.equals((Object)skipUndoDateTimeField0));
      assertFalse(skipUndoDateTimeField3.equals((Object)skipUndoDateTimeField2));
      assertFalse(skipUndoDateTimeField3.equals((Object)skipUndoDateTimeField1));
      assertFalse(skipUndoDateTimeField3.equals((Object)skipUndoDateTimeField0));
      assertFalse(int1 == int0);
      assertEquals((-292269053), skipUndoDateTimeField2.getMinimumValue());
      assertEquals((-292269052), skipUndoDateTimeField3.getMinimumValue());
      assertNotSame(skipUndoDateTimeField2, skipUndoDateTimeField1);
      assertNotSame(skipUndoDateTimeField2, skipUndoDateTimeField3);
      assertNotSame(skipUndoDateTimeField2, skipUndoDateTimeField0);
      assertNotSame(skipUndoDateTimeField3, skipUndoDateTimeField2);
      assertNotSame(skipUndoDateTimeField3, skipUndoDateTimeField1);
      assertNotSame(skipUndoDateTimeField3, skipUndoDateTimeField0);
      
      long long2 = skipUndoDateTimeField2.set((-952L), 0);
      assertEquals(2277L, long2);
      assertFalse(skipUndoDateTimeField2.equals((Object)skipUndoDateTimeField1));
      assertFalse(skipUndoDateTimeField2.equals((Object)skipUndoDateTimeField3));
      assertFalse(skipUndoDateTimeField2.equals((Object)skipUndoDateTimeField0));
      assertTrue(long2 == long0);
      assertFalse(long2 == long1);
      assertEquals((-292269053), skipUndoDateTimeField2.getMinimumValue());
      assertNotSame(skipUndoDateTimeField2, skipUndoDateTimeField1);
      assertNotSame(skipUndoDateTimeField2, skipUndoDateTimeField3);
      assertNotSame(skipUndoDateTimeField2, skipUndoDateTimeField0);
      
      int int2 = skipUndoDateTimeField1.get(0);
      assertEquals(1, int2);
      assertFalse(skipUndoDateTimeField0.equals((Object)skipUndoDateTimeField3));
      assertFalse(skipUndoDateTimeField0.equals((Object)skipUndoDateTimeField1));
      assertFalse(skipUndoDateTimeField0.equals((Object)skipUndoDateTimeField2));
      assertFalse(skipUndoDateTimeField1.equals((Object)skipUndoDateTimeField3));
      assertFalse(skipUndoDateTimeField1.equals((Object)skipUndoDateTimeField2));
      assertFalse(skipUndoDateTimeField1.equals((Object)skipUndoDateTimeField0));
      assertFalse(int2 == int0);
      assertFalse(int2 == int1);
      assertEquals(1, skipUndoDateTimeField0.getMinimumValue());
      assertEquals(0, skipUndoDateTimeField1.getMinimumValue());
      assertNotSame(skipUndoDateTimeField0, skipUndoDateTimeField3);
      assertNotSame(skipUndoDateTimeField0, skipUndoDateTimeField1);
      assertNotSame(skipUndoDateTimeField0, skipUndoDateTimeField2);
      assertNotSame(skipUndoDateTimeField1, skipUndoDateTimeField3);
      assertNotSame(skipUndoDateTimeField1, skipUndoDateTimeField2);
      assertNotSame(skipUndoDateTimeField1, skipUndoDateTimeField0);
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      Chronology chronology0 = mock(Chronology.class, new ViolatedAssumptionAnswer());
      DateTimeField dateTimeField0 = mock(DateTimeField.class, new ViolatedAssumptionAnswer());
      doReturn((int[]) null).when(dateTimeField0).add(any(org.joda.time.ReadablePartial.class) , anyInt() , any(int[].class) , anyInt());
      doReturn(0).when(dateTimeField0).getMaximumValue();
      doReturn(0).when(dateTimeField0).getMinimumValue();
      doReturn((DateTimeFieldType) null).when(dateTimeField0).getType();
      SkipUndoDateTimeField skipUndoDateTimeField0 = new SkipUndoDateTimeField(chronology0, dateTimeField0);
      assertEquals(0, skipUndoDateTimeField0.getMinimumValue());
      assertNotNull(skipUndoDateTimeField0);
      
      SkipUndoDateTimeField skipUndoDateTimeField1 = new SkipUndoDateTimeField(chronology0, skipUndoDateTimeField0, 366);
      assertFalse(skipUndoDateTimeField1.equals((Object)skipUndoDateTimeField0));
      assertEquals(0, skipUndoDateTimeField0.getMinimumValue());
      assertEquals(1, skipUndoDateTimeField1.getMinimumValue());
      assertNotNull(skipUndoDateTimeField1);
      
      ReadablePartial readablePartial0 = mock(ReadablePartial.class, new ViolatedAssumptionAnswer());
      int[] intArray0 = new int[0];
      int[] intArray1 = skipUndoDateTimeField1.add(readablePartial0, (-3376), intArray0, 0);
      assertArrayEquals(new int[] {}, intArray0);
      assertFalse(skipUndoDateTimeField0.equals((Object)skipUndoDateTimeField1));
      assertFalse(skipUndoDateTimeField1.equals((Object)skipUndoDateTimeField0));
      assertEquals(0, skipUndoDateTimeField0.getMinimumValue());
      assertEquals(1, skipUndoDateTimeField1.getMinimumValue());
      assertNotSame(skipUndoDateTimeField0, skipUndoDateTimeField1);
      assertNotSame(skipUndoDateTimeField1, skipUndoDateTimeField0);
      assertNull(intArray1);
      
      int int0 = skipUndoDateTimeField1.getMinimumValue();
      assertEquals(1, int0);
      assertFalse(skipUndoDateTimeField0.equals((Object)skipUndoDateTimeField1));
      assertFalse(skipUndoDateTimeField1.equals((Object)skipUndoDateTimeField0));
      assertEquals(0, skipUndoDateTimeField0.getMinimumValue());
      assertEquals(1, skipUndoDateTimeField1.getMinimumValue());
      assertNotSame(skipUndoDateTimeField0, skipUndoDateTimeField1);
      assertNotSame(skipUndoDateTimeField1, skipUndoDateTimeField0);
      
      int int1 = skipUndoDateTimeField1.getMinimumValue();
      assertEquals(1, int1);
      assertFalse(skipUndoDateTimeField0.equals((Object)skipUndoDateTimeField1));
      assertFalse(skipUndoDateTimeField1.equals((Object)skipUndoDateTimeField0));
      assertTrue(int1 == int0);
      assertEquals(0, skipUndoDateTimeField0.getMinimumValue());
      assertEquals(1, skipUndoDateTimeField1.getMinimumValue());
      assertNotSame(skipUndoDateTimeField0, skipUndoDateTimeField1);
      assertNotSame(skipUndoDateTimeField1, skipUndoDateTimeField0);
      
      // Undeclared exception!
      try { 
        skipUndoDateTimeField1.set(357L, 15);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.joda.time.IllegalFieldValueException", e);
      }
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      Chronology chronology0 = mock(Chronology.class, new ViolatedAssumptionAnswer());
      DateTimeField dateTimeField0 = mock(DateTimeField.class, new ViolatedAssumptionAnswer());
      doReturn(0, 0).when(dateTimeField0).getMaximumValue();
      doReturn(0).when(dateTimeField0).getMinimumValue();
      doReturn((DateTimeFieldType) null).when(dateTimeField0).getType();
      SkipUndoDateTimeField skipUndoDateTimeField0 = new SkipUndoDateTimeField(chronology0, dateTimeField0);
      assertEquals(0, skipUndoDateTimeField0.getMinimumValue());
      assertNotNull(skipUndoDateTimeField0);
      
      SkipUndoDateTimeField skipUndoDateTimeField1 = new SkipUndoDateTimeField(chronology0, skipUndoDateTimeField0, 0);
      assertFalse(skipUndoDateTimeField1.equals((Object)skipUndoDateTimeField0));
      assertEquals(0, skipUndoDateTimeField0.getMinimumValue());
      assertEquals(0, skipUndoDateTimeField1.getMinimumValue());
      assertNotNull(skipUndoDateTimeField1);
      
      // Undeclared exception!
      try { 
        skipUndoDateTimeField1.set((long) 0, 0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.joda.time.IllegalFieldValueException", e);
      }
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      Chronology chronology0 = mock(Chronology.class, new ViolatedAssumptionAnswer());
      SkipUndoDateTimeField skipUndoDateTimeField0 = null;
      try {
        skipUndoDateTimeField0 = new SkipUndoDateTimeField(chronology0, (DateTimeField) null, 0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // The field must not be null
         //
         verifyException("org.joda.time.field.DelegatedDateTimeField", e);
      }
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      SkipUndoDateTimeField skipUndoDateTimeField0 = null;
      try {
        skipUndoDateTimeField0 = new SkipUndoDateTimeField((Chronology) null, (DateTimeField) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // The field must not be null
         //
         verifyException("org.joda.time.field.DelegatedDateTimeField", e);
      }
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      Chronology chronology0 = mock(Chronology.class, new ViolatedAssumptionAnswer());
      DateTimeField dateTimeField0 = mock(DateTimeField.class, new ViolatedAssumptionAnswer());
      doReturn(0).when(dateTimeField0).getMaximumValue();
      doReturn(0).when(dateTimeField0).getMinimumValue();
      doReturn((DateTimeFieldType) null).when(dateTimeField0).getType();
      SkipUndoDateTimeField skipUndoDateTimeField0 = new SkipUndoDateTimeField(chronology0, dateTimeField0, (-615));
      assertEquals(0, skipUndoDateTimeField0.getMinimumValue());
      assertNotNull(skipUndoDateTimeField0);
      
      SkipUndoDateTimeField skipUndoDateTimeField1 = new SkipUndoDateTimeField(chronology0, skipUndoDateTimeField0);
      assertFalse(skipUndoDateTimeField1.equals((Object)skipUndoDateTimeField0));
      assertEquals(0, skipUndoDateTimeField0.getMinimumValue());
      assertEquals(0, skipUndoDateTimeField1.getMinimumValue());
      assertNotNull(skipUndoDateTimeField1);
      
      // Undeclared exception!
      try { 
        skipUndoDateTimeField1.set((long) (-615), (-615));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.joda.time.IllegalFieldValueException", e);
      }
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      Chronology chronology0 = mock(Chronology.class, new ViolatedAssumptionAnswer());
      DateTimeField dateTimeField0 = mock(DateTimeField.class, new ViolatedAssumptionAnswer());
      doReturn(0).when(dateTimeField0).get(anyLong());
      doReturn((String) null).when(dateTimeField0).getAsText(anyLong());
      doReturn(0).when(dateTimeField0).getMinimumValue();
      doReturn((DateTimeFieldType) null).when(dateTimeField0).getType();
      SkipUndoDateTimeField skipUndoDateTimeField0 = new SkipUndoDateTimeField(chronology0, dateTimeField0);
      skipUndoDateTimeField0.getAsText(1L);
      SkipUndoDateTimeField skipUndoDateTimeField1 = new SkipUndoDateTimeField(chronology0, skipUndoDateTimeField0, 1506);
      SkipUndoDateTimeField skipUndoDateTimeField2 = new SkipUndoDateTimeField(chronology0, skipUndoDateTimeField1);
      assertEquals(0, skipUndoDateTimeField2.getMinimumValue());
      
      int int0 = skipUndoDateTimeField1.get(134L);
      assertEquals(1, skipUndoDateTimeField1.getMinimumValue());
      assertEquals(1, int0);
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      Chronology chronology0 = mock(Chronology.class, new ViolatedAssumptionAnswer());
      int[] intArray0 = new int[1];
      intArray0[0] = 2010;
      DateTimeField dateTimeField0 = mock(DateTimeField.class, new ViolatedAssumptionAnswer());
      doReturn((-2315)).when(dateTimeField0).get(anyLong());
      doReturn(2010).when(dateTimeField0).getMinimumValue();
      doReturn((DateTimeFieldType) null).when(dateTimeField0).getType();
      SkipUndoDateTimeField skipUndoDateTimeField0 = new SkipUndoDateTimeField(chronology0, dateTimeField0);
      SkipUndoDateTimeField skipUndoDateTimeField1 = new SkipUndoDateTimeField(chronology0, skipUndoDateTimeField0, 0);
      ReadablePartial readablePartial0 = mock(ReadablePartial.class, new ViolatedAssumptionAnswer());
      int int0 = skipUndoDateTimeField1.get(0);
      assertEquals(2010, skipUndoDateTimeField1.getMinimumValue());
      assertEquals((-2313), int0);
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      Chronology chronology0 = mock(Chronology.class, new ViolatedAssumptionAnswer());
      DateTimeField dateTimeField0 = mock(DateTimeField.class, new ViolatedAssumptionAnswer());
      doReturn(0L).when(dateTimeField0).add(anyLong() , anyInt());
      doReturn((int[]) null).when(dateTimeField0).addWrapField(any(org.joda.time.ReadablePartial.class) , anyInt() , any(int[].class) , anyInt());
      doReturn(0, 0).when(dateTimeField0).get(anyLong());
      doReturn((String) null).when(dateTimeField0).getAsText(any(org.joda.time.ReadablePartial.class) , anyInt() , any(java.util.Locale.class));
      doReturn(0, 0, 0).when(dateTimeField0).getMaximumValue();
      doReturn(0).when(dateTimeField0).getMaximumValue(any(org.joda.time.ReadablePartial.class));
      doReturn(0).when(dateTimeField0).getMaximumValue(any(org.joda.time.ReadablePartial.class) , any(int[].class));
      doReturn(0).when(dateTimeField0).getMinimumValue();
      doReturn((DateTimeFieldType) null).when(dateTimeField0).getType();
      doReturn(0L).when(dateTimeField0).set(anyLong() , anyInt());
      SkipUndoDateTimeField skipUndoDateTimeField0 = new SkipUndoDateTimeField(chronology0, dateTimeField0, (-1));
      SkipUndoDateTimeField skipUndoDateTimeField1 = new SkipUndoDateTimeField(chronology0, skipUndoDateTimeField0);
      SkipUndoDateTimeField skipUndoDateTimeField2 = new SkipUndoDateTimeField(chronology0, skipUndoDateTimeField1, (-1));
      ReadablePartial readablePartial0 = mock(ReadablePartial.class, new ViolatedAssumptionAnswer());
      skipUndoDateTimeField1.getMaximumValue(readablePartial0);
      ReadablePartial readablePartial1 = mock(ReadablePartial.class, new ViolatedAssumptionAnswer());
      Locale locale0 = Locale.GERMAN;
      LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
      Locale.FilteringMode locale_FilteringMode0 = Locale.FilteringMode.EXTENDED_FILTERING;
      Locale.filterTags((List<Locale.LanguageRange>) linkedList0, (Collection<String>) null, locale_FilteringMode0);
      skipUndoDateTimeField2.getAsText(readablePartial1, 0, locale0);
      skipUndoDateTimeField2.add(0L, (-1));
      int int0 = skipUndoDateTimeField0.getMinimumValue();
      assertEquals((-1), int0);
      
      int int1 = skipUndoDateTimeField1.getMinimumValue();
      int int2 = skipUndoDateTimeField1.get((-2132L));
      assertTrue(int2 == int1);
      
      skipUndoDateTimeField2.set((long) 0, 0);
      ReadablePartial readablePartial2 = mock(ReadablePartial.class, new ViolatedAssumptionAnswer());
      int[] intArray0 = new int[6];
      intArray0[0] = 0;
      intArray0[1] = 0;
      intArray0[2] = (-1);
      intArray0[3] = 0;
      ReadablePartial readablePartial3 = mock(ReadablePartial.class, new ViolatedAssumptionAnswer());
      skipUndoDateTimeField0.addWrapField(readablePartial3, (-1), intArray0, 0);
      intArray0[4] = (-1);
      intArray0[5] = 0;
      skipUndoDateTimeField2.getMaximumValue(readablePartial2, intArray0);
      skipUndoDateTimeField1.getMinimumValue();
      skipUndoDateTimeField0.get(1387L);
      skipUndoDateTimeField2.getMinimumValue();
      int int3 = skipUndoDateTimeField0.getMinimumValue();
      assertEquals((-1), int3);
  }
}
